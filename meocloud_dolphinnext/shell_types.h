/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef shell_TYPES_H
#define shell_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>



namespace Shell {

struct NotificationType {
  enum type {
    FILE_STATUS = 0
  };
};

extern const std::map<int, const char*> _NotificationType_VALUES_TO_NAMES;

struct FileState {
  enum type {
    READY = 0,
    SYNCING = 1,
    IGNORED = 2,
    ERROR = 3
  };
};

extern const std::map<int, const char*> _FileState_VALUES_TO_NAMES;

struct MessageType {
  enum type {
    SUBSCRIBE_PATH = 0,
    SHARE = 1,
    OPEN = 2,
    FILE_STATUS = 3
  };
};

extern const std::map<int, const char*> _MessageType_VALUES_TO_NAMES;

struct SubscribeType {
  enum type {
    SUBSCRIBE = 0,
    UNSUBSCRIBE = 1
  };
};

extern const std::map<int, const char*> _SubscribeType_VALUES_TO_NAMES;

struct ShareType {
  enum type {
    LINK = 0,
    FOLDER = 1
  };
};

extern const std::map<int, const char*> _ShareType_VALUES_TO_NAMES;

struct OpenType {
  enum type {
    BROWSER = 0
  };
};

extern const std::map<int, const char*> _OpenType_VALUES_TO_NAMES;

struct FileStatusType {
  enum type {
    REQUEST = 0,
    RESPONSE = 1,
    MULTI_REQUEST = 2,
    MULTI_RESPONSE = 3
  };
};

extern const std::map<int, const char*> _FileStatusType_VALUES_TO_NAMES;

typedef struct _SubscribeMessage__isset {
  _SubscribeMessage__isset() : type(false), path(false) {}
  bool type;
  bool path;
} _SubscribeMessage__isset;

class SubscribeMessage {
 public:

  static const char* ascii_fingerprint; // = "19B5240589E680301A7E32DF3971EFBE";
  static const uint8_t binary_fingerprint[16]; // = {0x19,0xB5,0x24,0x05,0x89,0xE6,0x80,0x30,0x1A,0x7E,0x32,0xDF,0x39,0x71,0xEF,0xBE};

  SubscribeMessage() : type((SubscribeType::type)0), path() {
  }

  virtual ~SubscribeMessage() throw() {}

  SubscribeType::type type;
  std::string path;

  _SubscribeMessage__isset __isset;

  void __set_type(const SubscribeType::type val) {
    type = val;
  }

  void __set_path(const std::string& val) {
    path = val;
  }

  bool operator == (const SubscribeMessage & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const SubscribeMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SubscribeMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SubscribeMessage &a, SubscribeMessage &b);

typedef struct _ShareMessage__isset {
  _ShareMessage__isset() : type(false), path(false) {}
  bool type;
  bool path;
} _ShareMessage__isset;

class ShareMessage {
 public:

  static const char* ascii_fingerprint; // = "19B5240589E680301A7E32DF3971EFBE";
  static const uint8_t binary_fingerprint[16]; // = {0x19,0xB5,0x24,0x05,0x89,0xE6,0x80,0x30,0x1A,0x7E,0x32,0xDF,0x39,0x71,0xEF,0xBE};

  ShareMessage() : type((ShareType::type)0), path() {
  }

  virtual ~ShareMessage() throw() {}

  ShareType::type type;
  std::string path;

  _ShareMessage__isset __isset;

  void __set_type(const ShareType::type val) {
    type = val;
  }

  void __set_path(const std::string& val) {
    path = val;
  }

  bool operator == (const ShareMessage & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const ShareMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShareMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ShareMessage &a, ShareMessage &b);

typedef struct _OpenMessage__isset {
  _OpenMessage__isset() : type(false), path(false) {}
  bool type;
  bool path;
} _OpenMessage__isset;

class OpenMessage {
 public:

  static const char* ascii_fingerprint; // = "19B5240589E680301A7E32DF3971EFBE";
  static const uint8_t binary_fingerprint[16]; // = {0x19,0xB5,0x24,0x05,0x89,0xE6,0x80,0x30,0x1A,0x7E,0x32,0xDF,0x39,0x71,0xEF,0xBE};

  OpenMessage() : type((OpenType::type)0), path() {
  }

  virtual ~OpenMessage() throw() {}

  OpenType::type type;
  std::string path;

  _OpenMessage__isset __isset;

  void __set_type(const OpenType::type val) {
    type = val;
  }

  void __set_path(const std::string& val) {
    path = val;
  }

  bool operator == (const OpenMessage & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const OpenMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OpenMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(OpenMessage &a, OpenMessage &b);

typedef struct _FileStatus__isset {
  _FileStatus__isset() : path(false), state(false) {}
  bool path;
  bool state;
} _FileStatus__isset;

class FileStatus {
 public:

  static const char* ascii_fingerprint; // = "D6FD826D949221396F4FFC3ECCD3D192";
  static const uint8_t binary_fingerprint[16]; // = {0xD6,0xFD,0x82,0x6D,0x94,0x92,0x21,0x39,0x6F,0x4F,0xFC,0x3E,0xCC,0xD3,0xD1,0x92};

  FileStatus() : path(), state((FileState::type)0) {
  }

  virtual ~FileStatus() throw() {}

  std::string path;
  FileState::type state;

  _FileStatus__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_state(const FileState::type val) {
    state = val;
  }

  bool operator == (const FileStatus & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(state == rhs.state))
      return false;
    return true;
  }
  bool operator != (const FileStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FileStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FileStatus &a, FileStatus &b);

typedef struct _FileStatusMessage__isset {
  _FileStatusMessage__isset() : type(false), status(false), statuses(false) {}
  bool type;
  bool status;
  bool statuses;
} _FileStatusMessage__isset;

class FileStatusMessage {
 public:

  static const char* ascii_fingerprint; // = "E9F06555B70E93F4D74ECD8026D902E9";
  static const uint8_t binary_fingerprint[16]; // = {0xE9,0xF0,0x65,0x55,0xB7,0x0E,0x93,0xF4,0xD7,0x4E,0xCD,0x80,0x26,0xD9,0x02,0xE9};

  FileStatusMessage() : type((FileStatusType::type)0) {
  }

  virtual ~FileStatusMessage() throw() {}

  FileStatusType::type type;
  FileStatus status;
  std::vector<FileStatus>  statuses;

  _FileStatusMessage__isset __isset;

  void __set_type(const FileStatusType::type val) {
    type = val;
  }

  void __set_status(const FileStatus& val) {
    status = val;
    __isset.status = true;
  }

  void __set_statuses(const std::vector<FileStatus> & val) {
    statuses = val;
    __isset.statuses = true;
  }

  bool operator == (const FileStatusMessage & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    if (__isset.statuses != rhs.__isset.statuses)
      return false;
    else if (__isset.statuses && !(statuses == rhs.statuses))
      return false;
    return true;
  }
  bool operator != (const FileStatusMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FileStatusMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FileStatusMessage &a, FileStatusMessage &b);

typedef struct _Message__isset {
  _Message__isset() : type(false), subscribe(false), share(false), open(false), fileStatus(false) {}
  bool type;
  bool subscribe;
  bool share;
  bool open;
  bool fileStatus;
} _Message__isset;

class Message {
 public:

  static const char* ascii_fingerprint; // = "35A13973CDD1A7E92A4B28FB84D66965";
  static const uint8_t binary_fingerprint[16]; // = {0x35,0xA1,0x39,0x73,0xCD,0xD1,0xA7,0xE9,0x2A,0x4B,0x28,0xFB,0x84,0xD6,0x69,0x65};

  Message() : type((MessageType::type)0) {
  }

  virtual ~Message() throw() {}

  MessageType::type type;
  SubscribeMessage subscribe;
  ShareMessage share;
  OpenMessage open;
  FileStatusMessage fileStatus;

  _Message__isset __isset;

  void __set_type(const MessageType::type val) {
    type = val;
  }

  void __set_subscribe(const SubscribeMessage& val) {
    subscribe = val;
    __isset.subscribe = true;
  }

  void __set_share(const ShareMessage& val) {
    share = val;
    __isset.share = true;
  }

  void __set_open(const OpenMessage& val) {
    open = val;
    __isset.open = true;
  }

  void __set_fileStatus(const FileStatusMessage& val) {
    fileStatus = val;
    __isset.fileStatus = true;
  }

  bool operator == (const Message & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.subscribe != rhs.__isset.subscribe)
      return false;
    else if (__isset.subscribe && !(subscribe == rhs.subscribe))
      return false;
    if (__isset.share != rhs.__isset.share)
      return false;
    else if (__isset.share && !(share == rhs.share))
      return false;
    if (__isset.open != rhs.__isset.open)
      return false;
    else if (__isset.open && !(open == rhs.open))
      return false;
    if (__isset.fileStatus != rhs.__isset.fileStatus)
      return false;
    else if (__isset.fileStatus && !(fileStatus == rhs.fileStatus))
      return false;
    return true;
  }
  bool operator != (const Message &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Message & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Message &a, Message &b);

} // namespace

#endif
