/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "shell_types.h"

#include <algorithm>

namespace Shell {

int _kNotificationTypeValues[] = {
  NotificationType::FILE_STATUS
};
const char* _kNotificationTypeNames[] = {
  "FILE_STATUS"
};
const std::map<int, const char*> _NotificationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kNotificationTypeValues, _kNotificationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kFileStateValues[] = {
  FileState::READY,
  FileState::SYNCING,
  FileState::IGNORED,
  FileState::ERROR
};
const char* _kFileStateNames[] = {
  "READY",
  "SYNCING",
  "IGNORED",
  "ERROR"
};
const std::map<int, const char*> _FileState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFileStateValues, _kFileStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMessageTypeValues[] = {
  MessageType::SUBSCRIBE_PATH,
  MessageType::SHARE,
  MessageType::OPEN,
  MessageType::FILE_STATUS
};
const char* _kMessageTypeNames[] = {
  "SUBSCRIBE_PATH",
  "SHARE",
  "OPEN",
  "FILE_STATUS"
};
const std::map<int, const char*> _MessageType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kMessageTypeValues, _kMessageTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSubscribeTypeValues[] = {
  SubscribeType::SUBSCRIBE,
  SubscribeType::UNSUBSCRIBE
};
const char* _kSubscribeTypeNames[] = {
  "SUBSCRIBE",
  "UNSUBSCRIBE"
};
const std::map<int, const char*> _SubscribeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSubscribeTypeValues, _kSubscribeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kShareTypeValues[] = {
  ShareType::LINK,
  ShareType::FOLDER
};
const char* _kShareTypeNames[] = {
  "LINK",
  "FOLDER"
};
const std::map<int, const char*> _ShareType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kShareTypeValues, _kShareTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kOpenTypeValues[] = {
  OpenType::BROWSER
};
const char* _kOpenTypeNames[] = {
  "BROWSER"
};
const std::map<int, const char*> _OpenType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kOpenTypeValues, _kOpenTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kFileStatusTypeValues[] = {
  FileStatusType::REQUEST,
  FileStatusType::RESPONSE,
  FileStatusType::MULTI_REQUEST,
  FileStatusType::MULTI_RESPONSE
};
const char* _kFileStatusTypeNames[] = {
  "REQUEST",
  "RESPONSE",
  "MULTI_REQUEST",
  "MULTI_RESPONSE"
};
const std::map<int, const char*> _FileStatusType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFileStatusTypeValues, _kFileStatusTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* SubscribeMessage::ascii_fingerprint = "19B5240589E680301A7E32DF3971EFBE";
const uint8_t SubscribeMessage::binary_fingerprint[16] = {0x19,0xB5,0x24,0x05,0x89,0xE6,0x80,0x30,0x1A,0x7E,0x32,0xDF,0x39,0x71,0xEF,0xBE};

uint32_t SubscribeMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (SubscribeType::type)ecast0;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SubscribeMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SubscribeMessage");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SubscribeMessage &a, SubscribeMessage &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

const char* ShareMessage::ascii_fingerprint = "19B5240589E680301A7E32DF3971EFBE";
const uint8_t ShareMessage::binary_fingerprint[16] = {0x19,0xB5,0x24,0x05,0x89,0xE6,0x80,0x30,0x1A,0x7E,0x32,0xDF,0x39,0x71,0xEF,0xBE};

uint32_t ShareMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->type = (ShareType::type)ecast1;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShareMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ShareMessage");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShareMessage &a, ShareMessage &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

const char* OpenMessage::ascii_fingerprint = "19B5240589E680301A7E32DF3971EFBE";
const uint8_t OpenMessage::binary_fingerprint[16] = {0x19,0xB5,0x24,0x05,0x89,0xE6,0x80,0x30,0x1A,0x7E,0x32,0xDF,0x39,0x71,0xEF,0xBE};

uint32_t OpenMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->type = (OpenType::type)ecast2;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OpenMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("OpenMessage");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OpenMessage &a, OpenMessage &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

const char* FileStatus::ascii_fingerprint = "D6FD826D949221396F4FFC3ECCD3D192";
const uint8_t FileStatus::binary_fingerprint[16] = {0xD6,0xFD,0x82,0x6D,0x94,0x92,0x21,0x39,0x6F,0x4F,0xFC,0x3E,0xCC,0xD3,0xD1,0x92};

uint32_t FileStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->state = (FileState::type)ecast3;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FileStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FileStatus");

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FileStatus &a, FileStatus &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.state, b.state);
  swap(a.__isset, b.__isset);
}

const char* FileStatusMessage::ascii_fingerprint = "E9F06555B70E93F4D74ECD8026D902E9";
const uint8_t FileStatusMessage::binary_fingerprint[16] = {0xE9,0xF0,0x65,0x55,0xB7,0x0E,0x93,0xF4,0xD7,0x4E,0xCD,0x80,0x26,0xD9,0x02,0xE9};

uint32_t FileStatusMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->type = (FileStatusType::type)ecast4;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statuses.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->statuses.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += this->statuses[_i9].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.statuses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FileStatusMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FileStatusMessage");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.statuses) {
    xfer += oprot->writeFieldBegin("statuses", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->statuses.size()));
      std::vector<FileStatus> ::const_iterator _iter10;
      for (_iter10 = this->statuses.begin(); _iter10 != this->statuses.end(); ++_iter10)
      {
        xfer += (*_iter10).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FileStatusMessage &a, FileStatusMessage &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.status, b.status);
  swap(a.statuses, b.statuses);
  swap(a.__isset, b.__isset);
}

const char* Message::ascii_fingerprint = "35A13973CDD1A7E92A4B28FB84D66965";
const uint8_t Message::binary_fingerprint[16] = {0x35,0xA1,0x39,0x73,0xCD,0xD1,0xA7,0xE9,0x2A,0x4B,0x28,0xFB,0x84,0xD6,0x69,0x65};

uint32_t Message::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->type = (MessageType::type)ecast11;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->subscribe.read(iprot);
          this->__isset.subscribe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->share.read(iprot);
          this->__isset.share = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->open.read(iprot);
          this->__isset.open = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fileStatus.read(iprot);
          this->__isset.fileStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Message::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Message");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.subscribe) {
    xfer += oprot->writeFieldBegin("subscribe", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->subscribe.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.share) {
    xfer += oprot->writeFieldBegin("share", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->share.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.open) {
    xfer += oprot->writeFieldBegin("open", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->open.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fileStatus) {
    xfer += oprot->writeFieldBegin("fileStatus", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->fileStatus.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Message &a, Message &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.subscribe, b.subscribe);
  swap(a.share, b.share);
  swap(a.open, b.open);
  swap(a.fileStatus, b.fileStatus);
  swap(a.__isset, b.__isset);
}

} // namespace
